<template>

      <div class="card text-center">
        <div class="card-header text-left">
          {{info.title}} by <strong>{{ info.email }}</strong>
        </div>
        <div class="card-body">
          <img class="card-img-top" :src="info.url" alt="slika">
        </div>
        <div class="card-footer text-left">
          <div>{{ timeAgo }}</div>

          <!--  <div v-if="showcomments">
            <div class="comments list-group">
              <a :key="c.id" v-for="c in comments" href="#" class="animate list-group-item list-group-item-action flex-column align-items-start">
                <div class="d-flex w-100 justify-content-between">
                  <small>{{ formatTime(c.posted_at) }} by {{ c.email }} </small>
                   Mogućnost da korisnik može odabrati brisanje komentara 
                  <a @click="removeComment(c.id)" href="#">Delete</a>
                </div>
                <small>{{ c.comment }}</small>
              </a>
            </div>

            <form @submit.prevent="postComment" class="form-inline mb-5">
              <div class="form-group">
                <input v-model="newComment" type="text" class="form-control" id="imageUrl" placeholder="Any comment?">
              </div>
              <button type="submit" class="btn btn-primary ml-2">Post</button>
            </form>
          </div> 
 -->
        </div>
      </div>

</template>

<script>
import moment from 'moment'
import store from '@/store.js'
import { Recepti } from '@/services'
export default {
  props: [ "info","showcomments"  ],
  data () {
    return {
      global: store,
      // newComment: "",
      //comments: []
    }
  },
  methods: {
     formatTime(t) {
      return moment(t.posted_at).fromNow()
    }, 
    
    async refresh() {   //da se komentari prilikom dodavanja prikažu automatski 
      let post = await Recepti.getOne(this.info.id);
     // this.get_comments();
    }, 
  },
    /* async postComment() {
      if (this.newComment) {
        let postId = this.info.id;    //this.info je trenutni Fipugram post
        let comment = {     //sadržaj komentara
          email: this.global.userEmail,
          comment: this.newComment,
          receptId: this.receptId
        };
        //try, catch, finally --> dobra praksa kod pozivanja udaljenih metoda na backendu
        try {
          await Recepti.Comments.add(receptId, comment);  //pozivamo gore definiranu metodu
        this.refresh();
        } catch (e) {
          console.error('Greška prilikom snimanja komentara', e);
        } finally {
          this.newComment = '';
        }
      }
    },
    async removeComment(commentId) {    //metoda za brisanje komentara
      let receptId = this.info.id;
      await Recepti.Comments.delete(receptId, commentId);
      this.refresh();
    }
  },
  async get_comments(){
    
      this.comments = await Recepti.Comments.get(this.info.id);
    
    }, */
  
  computed: {
    timeAgo () {
      return moment(this.info.posted_at).fromNow()
    }
  }
  /* mounted(){
    this.get_comments();
  }  */
}
</script>

<style>
  .card {
    margin-bottom: 10px
  }
  .comments {
    margin: 20px 0
  }
  /* ----------------------------------------------
  * Generated by Animista on 2020-1-3 19:19:35
  * Licensed under FreeBSD License.
  * See http://animista.net/license for more info. 
  * w: http://animista.net, t: @cssanimista
  * ---------------------------------------------- */
  @-webkit-keyframes fade-in-fwd{0%{-webkit-transform:translateZ(-80px);transform:translateZ(-80px);opacity:0}100%{-webkit-transform:translateZ(0);transform:translateZ(0);opacity:1}}@keyframes fade-in-fwd{0%{-webkit-transform:translateZ(-80px);transform:translateZ(-80px);opacity:0}100%{-webkit-transform:translateZ(0);transform:translateZ(0);opacity:1}}
  .animate{-webkit-animation:fade-in-fwd 1s cubic-bezier(.39,.575,.565,1.000) both;animation:fade-in-fwd 1s cubic-bezier(.39,.575,.565,1.000) both}
</style>